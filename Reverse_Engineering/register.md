<aside>
💡 암기 해야 할 것들

</aside>

### **범용 레지스터 🧺**

범용 레지스터는 주용도는 있으나, 그 외 임의의 용도로도 사용될 수 있는 레지스터입니다. x86-64에서 각각의 범용 레지스터는 8바이트를 저장할 수 있으며, 부호 없는 정수를 기준으로 2^64 - 1까지 나타낼 수 있습니다.

자주 쓰이는 범용 레지스터들의 주용도는 다음과 같습니다. 여기 서술된 레지스터 외에도 x64에는 r8, r9, … , r15까지의 범용레지스터가 더 존재합니다.

| 이름 | 주용도 |
| --- | --- |
| rax (accumulator register) | 함수의 반환 값 |
| rbx (base register) | x64에서는 주된 용도 없음 |
| rcx (counter register) | 반복문의 반복 횟수, 각종 연산의 시행 횟수 |
| rdx (data register) | x64에서는 주된 용도 없음 |
| rsi (source index) | 데이터를 옮길 때 원본을 가리키는 포인터 |
| rdi (destination index) | 데이터를 옮길 때 목적지를 가리키는 포인터 |
| rsp (stack pointer) | 사용중인 스택의 위치를 가리키는 포인터 |
| rbp (stack base pointer) | 스택의 바닥을 가리키는 포인터 |

플래그 레지스터 🏳️🏴
플래그 레지스터는 프로세서의 현재 상태를 저장하고 있는 레지스터입니다. x64 아키텍처에서는 RFLAGS라고 불리는 64비트 크기의 플래그 레지스터가 존재하며, 과거 16비트 플래그 레지스터가 확장된 것입니다. 깃발을 올리고, 내리는 행위로 신호를 전달하듯, 플래그 레지스터는 자신을 구성하는 여러 비트들로 CPU의 현재 상태를 표현합니다.

플래그 레지스터의 여러 플래그 비트들 중 앞으로 주로 접하게 될 것들은 다음과 같습니다.

플래그

의미

CF(Carry Flag)

부호 없는 수의 연산 결과가 비트의 범위를 넘을 경우 설정 됩니다.

ZF(Zero Flag)

연산의 결과가 0일 경우 설정 됩니다.

SF(Sign Flag)

연산의 결과가 음수일 경우 설정 됩니다.

OF(Overflow Flag)

부호 있는 수의 연산 결과가 비트 범위를 넘을 경우 설정 됩니다.

### **레지스터 호환**

앞에서 x86-64 아키텍처는 IA-32의 64비트 확장 아키텍처이며, 호환이 가능하다고 했습니다. IA-32에서 CPU의 레지스터들은 32비트 크기를 가지며, 이들의 명칭은 각각 *eax, ebx, ecx, edx, esi, edi, esp, ebp*였습니다. 호환성을 위해 이 레지스터들은 x86-64에서도 그대로 사용이 가능합니다.

앞서 소개드린 *rax, rbx, rcx, rdx, rsi, rdi, rsp, rbp*가 이들의 확장된 형태이며, eax, ebx 등은 확장된 레지스터의 하위 32비트를 가리킵니다. 예를 들어, *eax는 rax*의 하위 32비트를 의미합니다.

또한 마찬가지로 과거 16비트 아키텍처인 IA-16과의 호환을 위해 *ax, bx, cx, dx, si, di, sp, bp*는 *eax, ebx*, *ecx*, *edx, esi, edi, esp ,ebp*의 하위 16비트를 가리킵니다.

이들 중 몇몇은 다시 상위 8비트, 하위 8비트로 나뉘는데 이들 전체에 대한 내용은 오른쪽 그림에서 확인할 수 있습니다.

**x86-64의 레지스터**

---

!https://dreamhack-lecture.s3.amazonaws.com/media/3989967ad96e63dbdcc95e58609a84caa679054b1db92b11fc959ca4b48d18aa.png
