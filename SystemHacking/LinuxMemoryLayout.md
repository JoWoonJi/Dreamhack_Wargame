# **리눅스 프로세스의 메모리 구조**

# **세그먼트**

리눅스에서는 프로세스의 메모리를 크게 5가지의 **세그먼트(Segment)** 로 구분합니다. 여기서 세그먼트란 적재되는 데이터의 용도별로 메모리의 구획을 나눈 것인데, 크게 코드 세그먼트, 데이터 세그먼트, BSS 세그먼트, 힙 세그먼트, 그리고 스택 세그먼트로 구분합니다.

![](https://dreamhack-lecture.s3.amazonaws.com/media/11c37c753220a7205496c81b1383bcae2d9f841a7b25d83141063a88cded42f1.png)

운영체제가 메모리를 용도별로 나누면, 각 용도에 맞게 적절한 권한을 부여할 수 있다는 장점이 있습니다. 권한은 읽기, 쓰기, 그리고 실행이 존재하며, CPU는 메모리에 대해 권한이 부여된 행위만 할 수 있습니다.

예를 들어, 데이터 세그먼트에는 프로그램이 실행되면서 사용하는 데이터가 적재됩니다. CPU는 이곳의 데이터를 읽을 수 있어야 하며, 따라서 이 영역에는 읽기 권한이 부여됩니다. 반면 이 영역의 데이터는 실행 대상이 아니므로 실행 권한은 부여되지 않습니다.

세그먼트를 자세히 이해하려면 운영체제의 메모리 관리기법 중 하나인 세그먼테이션 기법과 인텔 x86-64(x64)에서 관련된 하드웨어의 설계를 조금 알아야 합니다. 하지만 이는 이 로드맵의 범위를 넘어가므로 여기서 다루지는 않겠습니다. '실행 중인 프로세스의 메모리가 오른쪽과 같이 5개의 영역으로 구분된다.' 정도로만 이해하시면 될 것 같습니다.

각각의 세그먼트에 대해 좀 더 자세히 살펴보겠습니다.

# **코드 세그먼트**

!https://dreamhack-lecture.s3.amazonaws.com/media/5204ca2cd71ee11825d8bb97d0e2920e0d0dcf777fef27822d4b087d9fea035a.png

**코드 세그먼트(Code Segment)**는 실행 가능한 기계 코드가 위치하는 영역으로 **텍스트 세그먼트(Text Segment)**라고도 불립니다.

프로그램이 동작하려면 코드를 실행할 수 있어야 하므로 이 세그먼트에는 읽기 권한 과 실행 권한 이 부여됩니다. 반면 쓰기 권한이 있으면 공격자가 악의적인 코드를 삽입하기가 쉬워지므로, 대부분의 현대 운영체제는 이 세그먼트에 쓰기 권한을 제거합니다.

아래에서 정수 31337을 반환하는 main함수가 컴파일 되면 554889e5b8697a00005dc3라는 기계 코드로 변환되는데, 이 기계 코드가 코드 세그먼트에 위치하게 됩니다.

|  | int main() { return 31337; } |
| --- | --- |

# **데이터 세그먼트**

!https://dreamhack-lecture.s3.amazonaws.com/media/c467d7ba16f62229b11749ab360e6ca803df4af664e16eba206b2803672cd790.png

**데이터 세그먼트(Data Segment)**에는 컴파일 시점에 값이 정해진 전역 변수 및 전역 상수들이 위치합니다. CPU가 이 세그먼트의 데이터를 읽을 수 있어야 하므로, 읽기 권한 이 부여됩니다.

데이터 세그먼트는 쓰기가 가능한 세그먼트와 쓰기가 불가능한 세그먼트로 다시 분류되는데, 쓰기가 가능한 세그먼트는 전역 변수와 같이 프로그램이 실행되면서 값이 변할 수 있는 데이터들이 위치합니다. 이런 세그먼트는 ***data 세그먼트***라고 부릅니다.

반면 쓰기가 불가능한 세그먼트에는 프로그램이 실행되면서 값이 변하면 안되는 데이터들이 위치합니다. 전역으로 선언된 상수가 여기에 포함됩니다. 이런 세그먼트를 ***rodata(read-only data) 세그먼트***라고 부릅니다.

아래는 데이터 세그먼트에 포함되는 여러 데이터의 유형입니다. 주의 깊게 살펴봐야할 변수는 str_ptr입니다. str_ptr은 “readonly”라는 문자열을 가리키고 있는데, 이 문자열은 상수 문자열로 취급되어 *rodata*에 위치하며, 이를 가리키는 str_ptr은 전역 변수로서 *data*에 위치합니다.

|  | int data_num = 31337;                       // data |
| --- | --- |
|  | char data_rwstr[] = "writable_data";        // data |
|  | const char data_rostr[] = "readonly_data";  // rodata |
|  | char *str_ptr = "readonly";  // str_ptr은 data, 문자열은 rodata |
|  |  |
|  | int main() { ... } |

# **BSS 세그먼트**

!https://dreamhack-lecture.s3.amazonaws.com/media/723d9d477ce69171e3c189ac6d09ad461f4f2094148e08228534f6a09cf242b4.png

**BSS 세그먼트(BSS Segment, Block Started By Symbol Segment)**는 컴파일 시점에 값이 정해지지 않은 전역 변수가 위치하는 메모리 영역입니다. 여기에는 개발자가 선언만 하고 초기화하지 않은 전역변수 등이 포함됩니다. 이 세그먼트의 메모리 영역은 프로그램이 시작될 때, 모두 0으로 값이 초기화됩니다. 이런 특성 때문에 C 코드를 작성할 때, 초기화되지 않은 전역 변수의 값은 0이됩니다.

이 세그먼트에는 읽기 권한 및 쓰기 권한이 부여됩니다.

아래 코드에서 초기화되지 않은 전역 변수인 bss_data가 BSS 세그먼트에 위치하게 됩니다.

|  | int bss_data; |
| --- | --- |
|  |  |
|  | int main() { |
|  | printf("%d\n", bss_data);  // 0 |
|  | return 0; |
|  | } |

# **스택 세그먼트**

!https://dreamhack-lecture.s3.amazonaws.com/media/aff95bc463854b0170c77c8208ae9ddf913b617b2c7290a414f1f1220071fb65.png

**스택 세그먼트(Stack Segment)**는 프로세스의 스택이 위치하는 영역입니다. 함수의 인자나 지역 변수와 같은 임시 변수들이 실행중에 여기에 저장됩니다.

앞으로 살펴보겠지만, 스택 세그먼트는 **스택 프레임(Stack Frame)** 이라는 단위로 사용됩니다. 스택 프레임은 함수가 호출될 때 생성되고, 반환될 때 해제됩니다. 그런데 프로그램의 전체 실행 흐름은 사용자의 입력을 비롯한 여러 요인에 영향을 받습니다.

👇*아래의 코드에서 유저가 입력한* choice*에 따라* call_true()*가 호출될 수도,* call_false()*가 호출될 수도 있습니다.*

|  | void func() { |
| --- | --- |
|  | int choice = 0; |
|  |  |
|  | scanf("%d", &choice); |
|  |  |
|  | if (choice) |
|  | call_true(); |
|  | else |
|  | call_false(); |
|  |  |
|  | return 0; |
|  | } |

따라서, 어떤 프로세스가 실행될 때, 이 프로세스가 얼마 만큼의 스택 프레임을 사용하게 될 지를 미리 계산하는 것은 일반적으로 불가능합니다. 그래서 운영체제는 프로세스를 시작할 때 작은 크기의 스택 세그먼트를 먼저 할당해주고, 부족해 질 때마다 이를 확장해줍니다. 스택에 대해서 ‘아래로 자란다' 라는 표현을 종종 사용하는데, 이는 스택이 확장될 때, 기존 주소보다 낮은 주소로 확장되기 때문입니다.

이 영역에는 CPU가 자유롭게 값을 읽고 쓸 수 있어야 하므로, 읽기 와 쓰기 권한 이 부여됩니다.

아래의 코드에서는 지역변수 choice가 스택에 저장되게 됩니다.

# **힙 세그먼트**

!https://dreamhack-lecture.s3.amazonaws.com/media/9870b37aa3fd663dfe72518a40445bf255baf03ca77c383a97fdf249ccb9d7b4.png

**힙 세그먼트(Heap Segment)**는 힙 데이터가 위치하는 세그먼트입니다. 스택과 마찬가지로 실행중에 동적으로 할당될 수 있으며, 리눅스에서는 스택 세그먼트와 반대 방향으로 자랍니다.

C언어에서 malloc(), calloc() 등을 호출해서 할당받는 메모리가 이 세그먼트에 위치하게 되며, 일반적으로 읽기와 쓰기 권한이 부여됩니다.

아래 예제 코드는 heap_data_ptr에 malloc()으로 동적 할당한 영역의 주소를 대입하고, 이 영역에 값을 씁니다. heap_data_ptr은 지역변수이므로 스택에 위치하며, malloc으로 할당받은 힙 세그먼트의 주소를 가리킵니다.

|  | int main() { |
| --- | --- |
|  | int *heap_data_ptr = |
|  | malloc(sizeof(*heap_data_ptr));  // 동적 할당한 힙 영역의 주소를 가리킴 |
|  | *heap_data_ptr = 31337;              // 힙 영역에 값을 씀 |
|  | printf("%d\n", *heap_data_ptr);  // 힙 영역의 값을 사용함 |
|  | return 0; |
|  | } |

💡 **힙과 스택 세그먼트가 자라는 방향이 반대인 이유?**

---

두 세그먼트가 동일한 방향으로 자라며, 연속된 메모리 주소에 각각 할당된다고 가정해봅시다. 이 경우, 기존의 힙 세그먼트를 모두 사용하고 나면, 이를 확장하는 과정에서 스택 세그먼트와 충돌하게 됩니다.

이를 쉽게 해결하기 위해 리눅스는 스택을 메모리의 끝에 위치시키고, 힙과 스택을 반대로 자라게 합니다. 이렇게 하면 힙과 스택은 메모리를 최대한 자유롭게 사용할 수 있으며, 충돌 문제로 부터도 비교적 자유롭게 됩니다.

---

| 세그먼트 | 역할 | 일반적인 권한 | 사용 예 |
| --- | --- | --- | --- |
| 코드 세그먼트 | 실행 가능한 코드가 저장된 영역 | 읽기, 실행 | main() 등의 함수 코드 |
| 데이터 세그먼트 | 초기화된 전역 변수 또는 상수가 위치하는 영역 | 읽기와 쓰기 또는 읽기 전용 | 초기화된 전역 변수, 전역 상수 |
| BSS 세그먼트 | 초기화되지 않은 데이터가 위치하는 영역 | 읽기, 쓰기 | 초기화되지 않은 전역 변수 |
| 스택 세그먼트 | 임시 변수가 저장되는 영역 | 읽기, 쓰기 | 지역 변수, 함수의 인자 등 |
| 힙 세그먼트 | 실행중에 동적으로 사용되는 영역 | 읽기, 쓰기 | malloc(), calloc() 등으로 할당 받은 메모리 |
