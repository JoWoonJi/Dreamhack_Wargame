gcc에서도 out of bound 취약점에 대해 아무 표시도 해주지 않으므로 반드시 인덱스의 값과 길이를 검사하는 코드를 작성해야한다.

예 )**if (index >= 0x10) {exit(-1);}** 

- **배열의 길이**: 배열이 포함하는 요소의 개수
- **배열의 크기**: ****배열의 길이 X 요소의 크기
- **배열의 참조**: 배열의 주소, 요소의 크기, 인덱스를 활용하여 참조할 요소의 주소를 계산함. 이 과정에서, 계산된 주소가 배열의 범위를 벗어나는지 검사하지 않으므로 out of bounds 취약점이 발생할 수 있음.
- **Out of Bounds(OOB)**: 배열의 범위를 벗어난 메모리에 접근할 수 있는 취약점. 개발자가 인덱스에 대한 검사를 제대로 하지 않으면 발생함. 임의 주소 읽기, 임의 주소 쓰기로 이어질 수 있음

1. 이름을 입력받는다.
2. idx를 입력받는다.
3. idx에 해당하는 command를 실행한다.

idx의 범위를 따로 검사하지 않으므로 command가 아닌 다른 변수에도 접근할 수 있어 보인다.

어셈블리어를 봤을 때 name의 주소는 0x804a0ac, command의 주소는 0x804a060인 것을 알 수 있다.

둘의 차이는 76이고, 하나당 4바이트씩 차지하므로, 76 / 4 = 19가 나온다.

따라서 name의 위치는 command[19]이다.

system 함수는 외부 라이브러리이기 때문에 변수 주소 (4바이트) + exec_code (인수) 로 구성되어 있다. 따라서 name + 4의 값과 cat flag를 인수로.

![out_of_bound.jpg](https://github.com/JoWoonJi/Dreamhack_Wargame/blob/main/SystemHacking/img/out_of_bound.jpg)

플래그 획득
